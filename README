Culea Cosmin
321 CA


						Project - Energy System



	Relationships between classes and packages distribution

		---Contract package---

			- contains 3 classes: ContractConsumer, ContractDistributor and
		ContractFactory and one interface: Contract which links previous classes
			- these classes help in simulating a real life dependency between
		the consumers and distributors in terms of "a consumer HAS A contract
		WITH A distributor" and "a distributor HAS A contract WITH A consumer".
		When two players sign a contract, each player has his unique contract,
		both of them being generated by the ContractFactory which implements
		a Factory design pattern.

		---Player package---

			- contains 3 classes: Consumer, Distributor and PlayerFactory and
		one interface: Player which abstracts the two types of players (consumer
		and distributor)
			- Consumer and Distributor are the classes which model the entities
		needed to simulate an energy system. They have an id, a budget, can
		sign or terminate a contract, receive money, pay debts and be bankrupt
		all of these being generalised by the Player interface. The relationship
		between them as far as the simulation is concerned is established 
		through the contract as follows: "a distributor HAS MANY consumer" and
		"a consumer HAS A distributor" at every given time (month).

		---Simulation package---

			- contains one class: Simulation in which are conceived all players 
		and are set up the relationships between them as in simulation of 
		real-life, every month being seen as a round in a game.
			- the most important methods which can be used are setPlayers, 
		setRounds, play and clearGame, and should be used in this exact order.
		The first two methos creates the game context, the third method runs all
		the actions and last remove the game context (players and rounds). 
		However, the backend of the game is encapsulated in private methods
		which are forward used in play method in order to have logical timeline.

		---Input package---

			- contains 6 classes which precisely model the input format: 
		EntitiesInput which HAS MANY DistributorInput and ConsumerInput, 
		ActionInput which HAS MANY CostsChanges and ConsumerInput, and Input
		which HAS AN EntitiesInput and HAS MANY ActionInput.
			- also contains 2 classes for reading and writing data from and in
		JSON format: InputLoader and Writer. 

		---Constants pachake---

			- contains Constants class which helps in making the code more 
		readable for reading and writing

	Flow and design patterns

		- the main method from Main class is the place where reading, playing
	and writing are combined. First the input is loaded by the InputLoader in an
	object of type Input. Moreover, the game access is made only through the 
	unique instance of Simulation which implements a Singleton pattern, because
	this class is rather a context, an "arena", for players to play. The
	simulation instance has a database (three lists) with all players which have 
	been part of the game in the whole simulation and all rounds which have to
	be executed. The players are set thourgh the method setPlayers which uses
	the PlayerFactory (which implemets a Factory pattern) to creates the 
	entities. This is the conditions that must be fulfilled in order for the
	game to be played properly. Then the play method runs all the rounds and 
	finally the database of simulation is written in the file given by 
	arguments. In the end, the database of the simulation instance (game) is
	cleared.
 